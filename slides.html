<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="generator" content="rustdoc">
    <title>Rust Workshop</title>

    
    <link rel="stylesheet" href="css/rust.css">
<link rel="stylesheet" href="css/sliderust.css">
<script src="js/sliderust.js"></script>


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <h1 class="title">Rust Workshop</h1>
    <p>HackEPFL</p>

<p>Dimiter Petrov &amp; Romain Ruetschi</p>

<p>November 12, 2014</p>

<h1 id="hello,-rust" class='section-header'><a
                           href="#hello,-rust">Hello, Rust</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, world!&quot;</span>);
}
</pre>
<pre class='rust '>
<span class='op'>&gt;</span> <span class='ident'>Hello</span>, <span class='macro'>world</span><span class='macro'>!</span>
</pre>

<h1 id="history" class='section-header'><a
                           href="#history">History</a></h1>
<ul>
<li>Started as a personal project in 2006 by Graydon Hoare</li>
<li>First compiler written in OCaml</li>
<li>Mozilla took over the project 3 years later</li>
<li>Compiler rewritten in Rust itself in 2010</li>
</ul>

<h1 id="why-rust-at-mozilla?" class='section-header'><a
                           href="#why-rust-at-mozilla?">Why Rust at Mozilla?</a></h1>
<ul>
<li>New experimental, highly parallel browser engine: Servo</li>
<li>Browsers evolve in a hostile, highly concurrent environment</li>
<li>Most security problems arise from memory safetey and concurrency issues</li>
<li>Thus needed a safer, saner systems language, with built-in concurrency</li>
</ul>

<h1 id="why-rust,-for-you?" class='section-header'><a
                           href="#why-rust,-for-you?">Why Rust, for you?</a></h1>
<ul>
<li>High-level features</li>
<li>Low-level control</li>
<li>Powerful Foreign Function Interface</li>
<li>Direct memory control</li>
<li>Guaranteed memory safety</li>
<li>Concurrency without data races</li>
<li>Zero cost abstractions</li>
</ul>

<h1 id="high-level-features" class='section-header'><a
                           href="#high-level-features">High-level features</a></h1>
<ul>
<li>Type inference</li>
<li>Lambdas</li>
<li>Closures</li>
<li>Structs and methods</li>
<li>Iterators</li>
<li>Algebraic data types</li>
<li>Pattern matching</li>
<li>Traits (= type classes)</li>
<li>Macros</li>
<li>Modules</li>
</ul>

<h1 id="but-first,-the-basics" class='section-header'><a
                           href="#but-first,-the-basics">But first, the basics</a></h1>
<ul>
<li>Primitive types</li>
<li>Variables bindings</li>
<li>Functions</li>
<li>Printing stuff</li>
<li>Control structures</li>
<li>Strings</li>
<li>Arrays, vectors and slices</li>
</ul>

<h1 id="numeric-types" class='section-header'><a
                           href="#numeric-types">Numeric types</a></h1>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Example</th>
        <th></th>
    </tr>
    <tr>
        <td>Signed integer</td>
        <td><code>int</code></td>
        <td><code>5i</code></td>
        <td></td>
    </tr>
    <tr>
        <td>Unsigned integer</td>
        <td><code>uint</code></td>
        <td><code>5u</code></td>
        <td></td>
    </tr>
    <tr>
        <td>8-bit uint</td>
        <td><code>u8</code></td>
        <td><code>5u8</code></td>
        <td></td>
    </tr>
    <tr>
        <td>16-bit uint</td>
        <td><code>u16</code></td>
        <td><code>5i</code></td>
        <td></td>
    </tr>
    <tr>
        <td>etc.</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>32-bit float</td>
        <td><code>f32</code></td>
        <td><code>3.14f32</code></td>
        <td></td>
    </tr>
    <tr>
        <td>64-bit float</td>
        <td><code>f64</code></td>
        <td><code>3.14_f64</code></td>
        <td></td>
    </tr>
</table>

<h1 id="primitive-types" class='section-header'><a
                           href="#primitive-types">Primitive types</a></h1>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Example</th>
        <th></th>
    </tr>
    <tr>
        <td>Unit</td>
        <td><code>()</code></td>
        <td><code>()</code></td>
        <td></td>
    </tr>
    <tr>
        <td>Boolean</td>
        <td><code>bool</code></td>
        <td><code>true | false</code></td>
        <td></td>
    </tr>
    <tr>
        <td>Array</td>
        <td><code>[T]</code></td>
        <td><code>[1, 2, 3]</code>
        <td>fixed size, can be allocated on either the stack or the heap</td>
    </tr>
    <tr>
        <td>Slice</td>
        <td><code>&[T]</code></td>
        <td><code>&[1, 2, 3]</code>
        <td>'view' into an array, doesn't own the data it points to, but borrows it</td>
    </tr>
    <tr>
        <td>Tuple</td>
        <td><code>(A, B, C...)</code></td>
        <td><code>("Rust", 2006i, 'r')</code></td>
        <td>32-bit unsigned word</td>
    </tr>
 
</table>

<h1 id="textual-types" class='section-header'><a
                           href="#textual-types">Textual types</a></h1>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Example</th>
        <th></th>
    </tr>
    <tr>
        <td>Unicode scalar value</td>
        <td><code>char</code></td>
        <td><code>'a'</code></td>
        <td>32-bit unsigned word</td>
    </tr>
    <tr>
        <td>Unicode scalar array</td>
        <td><code>[char]</code></td>
        <td><code>['a', 'b', 'c']</code></td>
        <td>~ UTF-32 string</td>
    </tr>
    <tr>
        <td>Unicode string</td>
        <td><code>str</code></td>
        <td><code>"rust is cool"</code></td>
        <td>array 8-bit unsigned bytes<br>
            ~ sequence of UTF-8 codepoints</td>
    </tr>
</table>

<h1 id="variables-bindings" class='section-header'><a
                           href="#variables-bindings">Variables bindings</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>int</span> <span class='op'>=</span> <span class='number'>5i</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>2i</span>;
<span class='ident'>y</span> <span class='op'>+=</span> <span class='number'>1</span>;
</pre>

<h1 id="mutability" class='section-header'><a
                           href="#mutability">Mutability</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;

<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>; <span class='comment'>// error</span>
</pre>

<h1 id="mutability-1" class='section-header'><a
                           href="#mutability-1">Mutability</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;

<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>; <span class='comment'>// ok</span>
</pre>

<h1 id="mutability-2" class='section-header'><a
                           href="#mutability-2">Mutability</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>;

<span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>y</span> <span class='op'>+</span> <span class='number'>1</span>;
</pre>

<h1 id="functions" class='section-header'><a
                           href="#functions">Functions</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>do_stuff</span>(<span class='number'>2</span>, <span class='number'>3</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;result is {}&quot;</span>, <span class='ident'>res</span>);
}

<span class='kw'>fn</span> <span class='ident'>do_stuff</span>(<span class='ident'>a</span>: <span class='ident'>int</span>, <span class='ident'>b</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>a</span> <span class='op'>+</span> <span class='ident'>b</span>;

    <span class='kw'>return</span> <span class='ident'>c</span> <span class='op'>*</span> <span class='number'>2</span>;
}
</pre>

<h1 id="functions-1" class='section-header'><a
                           href="#functions-1">Functions</a></h1>
<p>You can omit <code>return</code> if you want return the last expression.</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>do_stuff</span>(<span class='number'>2</span>, <span class='number'>3</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;result is {}&quot;</span>, <span class='ident'>res</span>);
}

<span class='kw'>fn</span> <span class='ident'>do_stuff</span>(<span class='ident'>a</span>: <span class='ident'>int</span>, <span class='ident'>b</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>a</span> <span class='op'>+</span> <span class='ident'>b</span>;

    <span class='ident'>c</span> <span class='op'>*</span> <span class='number'>2</span> <span class='comment'>// ! no semicolon</span>
}
</pre>

<p>But you also need to omit the last semicolon, otherwise the function will return <code>()</code>.</p>

<h1 id="printing-stuff" class='section-header'><a
                           href="#printing-stuff">Printing stuff</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;John&quot;</span>;
    <span class='kw'>let</span> <span class='ident'>age</span> <span class='op'>=</span> <span class='number'>42</span>;
    
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is {}&quot;</span>, <span class='ident'>name</span>, <span class='ident'>age</span>);
}
</pre>

<h1 id="printing-stuff-1" class='section-header'><a
                           href="#printing-stuff-1">Printing stuff</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>name</span> <span class='op'>=</span> <span class='string'>&quot;John&quot;</span>;
    <span class='kw'>let</span> <span class='ident'>age</span> <span class='op'>=</span> <span class='number'>42</span>;
    
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{1} is {0}&quot;</span>, <span class='ident'>age</span>, <span class='ident'>name</span>);
}
</pre>

<h1 id="conditionals" class='section-header'><a
                           href="#conditionals">Conditionals</a></h1><pre class='rust '>
<span class='kw'>if</span> <span class='ident'>age</span> <span class='op'>&gt;</span> <span class='number'>16</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Have a beer!&quot;</span>);
}
<span class='kw'>else</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Sorry, no beer for you.&quot;</span>);
}
</pre>

<h1 id="conditionals-1" class='section-header'><a
                           href="#conditionals-1">Conditionals</a></h1>
<p><code>if/else</code> is an expression:</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='ident'>message</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='ident'>health</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
    <span class='string'>&quot;Good job&quot;</span>
} <span class='kw'>else</span> {
    <span class='string'>&quot;Game over&quot;</span>
};

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>message</span>);
</pre>

<h1 id="while" class='section-header'><a
                           href="#while">While</a></h1><pre class='rust '>
<span class='kw'>while</span> <span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>10</span> {
    <span class='comment'>// do stuff</span>
}
</pre>

<h1 id="loop" class='section-header'><a
                           href="#loop">Loop</a></h1>
<p>Instead of</p>
<pre class='rust '>
<span class='kw'>while</span> <span class='boolval'>true</span> {
    <span class='comment'>// do stuff</span>
}
</pre>

<p>use</p>
<pre class='rust '>
<span class='kw'>loop</span> {
    <span class='comment'>// do stuff</span>
}
</pre>

<p>Rust&#39;s control-flow analysis treats this construct differently than a <code>while true</code>, which leads to better generated code.</p>

<h1 id="for" class='section-header'><a
                           href="#for">For</a></h1><pre class='rust '>
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>range</span>(<span class='number'>0i</span>, <span class='number'>10i</span>) {
    <span class='comment'>// do stuff</span>
}
</pre>

<h1 id="for-1" class='section-header'><a
                           href="#for-1">For</a></h1><pre class='rust '>
<span class='kw'>for</span> <span class='ident'>var</span> <span class='kw'>in</span> <span class='ident'>expression</span> {
    <span class='ident'>code</span>
}
</pre>

<p><code>expression</code> must be an <code>Iterator</code> (we&#39;ll talk about it later).</p>

<h1 id="strings" class='section-header'><a
                           href="#strings">Strings</a></h1>
<ul>
<li>Guaranteed to be validly-encoded UTF-8 sequences</li>
<li>Not null-terminated (can contain null bytes)</li>
<li>Can be constant strings (<code>&amp;str</code>) or growable strings (<code>String</code>)</li>
</ul>

<h1 id="string-slices-(&amp;str)" class='section-header'><a
                           href="#string-slices-(&amp;str)">String slices (<code>&amp;str</code>)</a></h1>
<p>A pointer and a length.
String slices are a &#39;view&#39; into already allocated strings like string literals:</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='string'>&quot;Hello, world!&quot;</span>;
</pre>

<h1 id="growable-strings-(string)" class='section-header'><a
                           href="#growable-strings-(string)">Growable strings (<code>String</code>)</a></h1><pre class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();
<span class='ident'>hello</span>.<span class='ident'>push_str</span>(<span class='string'>&quot;, world!&quot;</span>);
<span class='comment'>// s containts &quot;Hello, world!&quot;</span>
</pre>

<h1 id="conversions-between-&amp;str-and-string" class='section-header'><a
                           href="#conversions-between-&amp;str-and-string">Conversions between <code>&amp;str</code> and <code>String</code></a></h1>
<ul>
<li>Call <code>as_slice()</code> on a <code>String</code> to convert it to a <code>&amp;str</code></li>
<li>Call <code>to_string()</code> on a <code>&amp;str</code> to convert it to a <code>String</code></li>
</ul>
<pre class='rust '>
<span class='kw'>let</span> <span class='ident'>s1</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>s2</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='ident'>s1</span>.<span class='ident'>as_slice</span>();
</pre>

<p>Converting <code>String</code> to <code>&amp;str</code> is cheap, converting <code>&amp;str</code> to <code>String</code> involves an allocation.</p>

<h1 id="arrays,-vectors-and-slices" class='section-header'><a
                           href="#arrays,-vectors-and-slices">Arrays, vectors and slices</a></h1>
<p>TODO</p>

<h1 id="low-level-control" class='section-header'><a
                           href="#low-level-control">Low-level control</a></h1>
<ul>
<li>Ability to trade compiler-enforced safety for lower-level control</li>
<li>Eg. dereferencing raw pointer, pointer arithmetic, calling extern code</li>
<li>Such unsafe code must be surrounded by an <code>unsafe</code> block</li>
<li>Thus easy to spot during code review or when debugging</li>
</ul>

<h1 id="powerful-ffi" class='section-header'><a
                           href="#powerful-ffi">Powerful FFI</a></h1>
<ul>
<li>Call Rust code from other languages (C, C++, or even GCed languages like Ruby)</li>
<li>Create bindings for libraries exposing a C interface</li>
</ul>

<h1 id="direct-memory-control" class='section-header'><a
                           href="#direct-memory-control">Direct memory control</a></h1>
<ul>
<li>No garbage collector</li>
<li>No runtime overhead</li>
<li>No unpredictable pauses in execution</li>
<li>TODO: Stack VS Heap</li>
</ul>

<h1 id="guaranteed-memory-safety" class='section-header'><a
                           href="#guaranteed-memory-safety">Guaranteed memory safety</a></h1>
<ul>
<li>No buffer overflows</li>
<li>No dangling pointers</li>
</ul>

<h1 id="concurrency-without-data-races" class='section-header'><a
                           href="#concurrency-without-data-races">Concurrency without data races</a></h1>
<ul>
<li>Only immutable data can be shared</li>
<li>Shared data must remain live as long as any task might access it</li>
</ul>

<h1 id="zero-cost-abstractions" class='section-header'><a
                           href="#zero-cost-abstractions">Zero cost abstractions</a></h1>
<p>Memory safety is enforced during compilation, there is no runtime overhead.</p>

<h1 id="but-how?" class='section-header'><a
                           href="#but-how?">But how?</a></h1>
<p>Rust is built around 3 concepts:</p>

<ul>
<li>Lifetime</li>
<li>Ownership</li>
<li>Borrowing</li>
</ul>

<h1 id="lifetime" class='section-header'><a
                           href="#lifetime">Lifetime</a></h1>
<p>Time span during which a resource (value) is valid.</p>

<h1 id="lifetime-1" class='section-header'><a
                           href="#lifetime-1">Lifetime</a></h1>
<p><img src="http://cl.ly/image/343C1X3o3K1s/Screen%20Shot%202014-11-10%20at%2018.06.58.png" alt=""></p>

<ul>
<li>You can think of it as a scope.</li>
<li>At the end of its lifetime, a value will be deallocated.</li>
</ul>

<h1 id="lifetime-2" class='section-header'><a
                           href="#lifetime-2">Lifetime</a></h1>
<pre><code class="language-c">{
    int *x = malloc(sizeof(int));

    *x = 5;

    free(x);
}
</code></pre>

<h1 id="lifetime-3" class='section-header'><a
                           href="#lifetime-3">Lifetime</a></h1><pre class='rust '>
{
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>5i</span>;
    
    <span class='comment'>// x gets deallocated here</span>
}
</pre>

<h1 id="move-&amp;-copy" class='section-header'><a
                           href="#move-&amp;-copy">Move &amp; Copy</a></h1>
<p>When you pass data to a function (or even assign it to a variable), that data can be copied, moved, or borrowed (more about it soon).</p>

<h1 id="copy" class='section-header'><a
                           href="#copy">Copy</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>add_one</span>(<span class='ident'>a</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>);
}

<span class='kw'>fn</span> <span class='ident'>add_one</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}
</pre>

<h1 id="move" class='section-header'><a
                           href="#move">Move</a></h1><pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Person</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
    <span class='ident'>age</span>: <span class='ident'>uint</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    <span class='ident'>show</span>(<span class='ident'>john</span>);
    
    <span class='comment'>// `john` has already been deallocated</span>
}

<span class='kw'>fn</span> <span class='ident'>show</span>(<span class='ident'>person</span>: <span class='ident'>Person</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is {}&quot;</span>, <span class='ident'>person</span>.<span class='ident'>name</span>, <span class='ident'>person</span>.<span class='ident'>age</span>);
    
    <span class='comment'>// `john` will be deallocated here</span>
}
</pre>

<h1 id="move-1" class='section-header'><a
                           href="#move-1">Move</a></h1><pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Person</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
    <span class='ident'>age</span>: <span class='ident'>uint</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    <span class='ident'>show</span>(<span class='ident'>john</span>);
    <span class='ident'>show</span>(<span class='ident'>john</span>);
}

<span class='kw'>fn</span> <span class='ident'>show</span>(<span class='ident'>person</span>: <span class='ident'>Person</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is {}&quot;</span>, <span class='ident'>person</span>.<span class='ident'>name</span>, <span class='ident'>person</span>.<span class='ident'>age</span>);
    
    <span class='comment'>// `john` will be deallocated here</span>
}
</pre>

<h1 id="move-2" class='section-header'><a
                           href="#move-2">Move</a></h1>
<pre><code class="language-norust">error: use of moved value: `john`
     show(john);
          ^
note: `john` moved here because it has type `Person`, which is non-copyable
     show(john);
          ^
error: aborting due to previous error
</code></pre>

<h1 id="move-3" class='section-header'><a
                           href="#move-3">Move</a></h1><pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='ident'>String</span>, <span class='ident'>age</span>: <span class='ident'>uint</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    
    <span class='comment'>// `john` moves into show here</span>
    <span class='ident'>show</span>(<span class='ident'>john</span>);
    <span class='comment'>// `john` is deallocated by now</span>
    <span class='comment'>// the next line thus doesn&#39;t compile</span>
    <span class='ident'>show</span>(<span class='ident'>john</span>);
}

<span class='kw'>fn</span> <span class='ident'>show</span>(<span class='ident'>person</span>: <span class='ident'>Person</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is {}&quot;</span>, <span class='ident'>person</span>.<span class='ident'>name</span>, <span class='ident'>person</span>.<span class='ident'>age</span>);
    
    <span class='comment'>// `john` will be deallocated here</span>
}
</pre>

<h1 id="move-(assignment)" class='section-header'><a
                           href="#move-(assignment)">Move (assignment)</a></h1>
<p>Assigning a value to a variable is similar to passing it to a function.</p>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='ident'>String</span>, <span class='ident'>age</span>: <span class='ident'>uint</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    
    <span class='comment'>// `john` moves into `john_bis` here</span>
    <span class='kw'>let</span> <span class='ident'>john_bis</span> <span class='op'>=</span> <span class='ident'>john</span>;
    
    <span class='comment'>// the next line thus won&#39;t compile</span>
    <span class='ident'>show</span>(<span class='ident'>john</span>);
}

<span class='kw'>fn</span> <span class='ident'>show</span>(<span class='ident'>person</span>: <span class='ident'>Person</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is {}&quot;</span>, <span class='ident'>person</span>.<span class='ident'>name</span>, <span class='ident'>person</span>.<span class='ident'>age</span>);
    
    <span class='comment'>// `john` will be deallocated here</span>
}
</pre>

<h1 id="ownership-&amp;-borrowing" class='section-header'><a
                           href="#ownership-&amp;-borrowing">Ownership &amp; Borrowing</a></h1>
<p>When you create a resource, you&#39;re the <strong>owner</strong> of that resource.</p>

<p>Being an owner affords you some privileges:</p>

<ul>
<li>You control when that resource is deallocated.</li>
<li>You may lend that resource, <strong>immutably</strong>, to <strong>as many</strong> borrowers as you&#39;d like.</li>
<li>You may lend that resource, <strong>mutably</strong>, to a <strong>single</strong> borrower.</li>
</ul>

<h1 id="ownership-&amp;-borrowing-1" class='section-header'><a
                           href="#ownership-&amp;-borrowing-1">Ownership &amp; Borrowing</a></h1>
<p>But it also comes with some restrictions:</p>

<ul>
<li>If someone is borrowing your resource (either mutably or immutably), you may not mutate the resource or mutably lend it to someone.</li>
<li>If someone is mutably borrowing your resource, you may not lend it out at all (mutably or immutably) or access it in any way.</li>
</ul>

<h1 id="borrow" class='section-header'><a
                           href="#borrow">Borrow</a></h1>
<blockquote>
<p>You may lend that resource, <strong>immutably</strong>, to <strong>as many</strong> borrowers as you&#39;d like.</p>
</blockquote>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='ident'>String</span>, <span class='ident'>age</span>: <span class='ident'>uint</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    
    <span class='comment'>// `john` moves into `show`.</span>
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>);
    
    <span class='comment'>// `show` hands us `john` back.</span>
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>);
    <span class='comment'>// the previous line will thus compile.</span>
}

<span class='kw'>fn</span> <span class='ident'>show</span>(<span class='ident'>person</span>: <span class='kw-2'>&amp;</span><span class='ident'>Person</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is {}&quot;</span>, <span class='ident'>person</span>.<span class='ident'>name</span>, <span class='ident'>person</span>.<span class='ident'>age</span>);
}
</pre>

<h1 id="borrow-1" class='section-header'><a
                           href="#borrow-1">Borrow</a></h1>
<pre><code class="language-norust">John is 42
John is 42
</code></pre>

<h1 id="mutable-borrow" class='section-header'><a
                           href="#mutable-borrow">Mutable borrow</a></h1>
<blockquote>
<p>You may lend that resource, <strong>mutably</strong>, to a <strong>single</strong> borrower.</p>
</blockquote>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='ident'>String</span>, <span class='ident'>age</span>: <span class='ident'>uint</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    
    <span class='ident'>grow_older</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>);
    
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>); <span class='comment'>// John is 43</span>
}

<span class='kw'>fn</span> <span class='ident'>grow_older</span>(<span class='ident'>person</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Person</span>) {
    <span class='ident'>person</span>.<span class='ident'>age</span> <span class='op'>+=</span> <span class='number'>1</span>;
}
</pre>

<h1 id="mutable-borrow-1" class='section-header'><a
                           href="#mutable-borrow-1">Mutable borrow</a></h1>
<p>The following will compile too, as <code>grow_older</code> gives us <code>john</code> back:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>); <span class='comment'>// John is 42</span>
    <span class='ident'>grow_older</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>);
    <span class='ident'>grow_older</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>);
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>); <span class='comment'>// John is 44</span>
}
</pre>

<h1 id="mutable-borrow-2" class='section-header'><a
                           href="#mutable-borrow-2">Mutable borrow</a></h1>
<p>But this won&#39;t:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>john_bis</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>;

    <span class='ident'>grow_older</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>);
    
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>);
}
</pre>

<h1 id="mutable-borrow-3" class='section-header'><a
                           href="#mutable-borrow-3">Mutable borrow</a></h1>
<pre><code class="language-norust">error: cannot borrow `john` as mutable more than once at a time
    grow_older(&amp;mut john);
                    ^
note: previous borrow of `john` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `p` until the borrow ends
    let mut john_bis = &amp;mut john;
                         ^
note: previous borrow ends here
fn main() {
...
}
^
error: aborting due to previous error
</code></pre>

<h1 id="mutable-borrow-4" class='section-header'><a
                           href="#mutable-borrow-4">Mutable borrow</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };

    <span class='comment'>// first borrow of `john` as mutable</span>
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>john_bis</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>;

    <span class='comment'>// `john` cannot be mutably borrowed again, won&#39;t compile</span>
    <span class='ident'>grow_older</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>);
    
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>);
}
</pre>

<h1 id="borrow-field-from-a-structure" class='section-header'><a
                           href="#borrow-field-from-a-structure">Borrow field from a structure</a></h1>
<p>TODO</p>

<h1 id="net-result" class='section-header'><a
                           href="#net-result">Net result</a></h1>
<ul>
<li>You never have to malloc or free </li>
<li>You never have to retain or release </li>
<li>Rust will deallocate a value when the current owner is done with it </li>
<li>The compiler will guarantee that borrowed values are not stolen</li>
</ul>

<h1 id="net-result-1" class='section-header'><a
                           href="#net-result-1">Net result</a></h1>
<ul>
<li>In low-level languages, we allocate and free memory, close sockets, etc.</li>
<li>In high-level languages, we never free memory, but we routinely close sockets and files, and release locks.</li>
<li>In Rust we do neither :)</li>
</ul>

<h1 id="high-level-features-1" class='section-header'><a
                           href="#high-level-features-1">High-level features</a></h1>
<h1 id="lambdas" class='section-header'><a
                           href="#lambdas">Lambdas</a></h1><pre class='rust '>
    <span class='kw'>let</span> <span class='ident'>xs</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>(<span class='number'>1i</span>, <span class='number'>2i</span>, <span class='number'>3i</span>);
    <span class='kw'>let</span> <span class='ident'>ys</span> <span class='op'>=</span> <span class='ident'>xs</span>.<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>*</span> <span class='number'>2</span>);

    <span class='comment'>// ys == [2i, 4i, 6i]</span>
</pre>

<h1 id="lambdas-1" class='section-header'><a
                           href="#lambdas-1">Lambdas</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>add_one</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}

<span class='kw'>fn</span> <span class='ident'>apply</span>(<span class='ident'>x</span>: <span class='ident'>int</span>, <span class='ident'>adder</span>: <span class='op'>|</span><span class='ident'>int</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='ident'>adder</span>(<span class='ident'>x</span>)
}
</pre>

<h1 id="closures" class='section-header'><a
                           href="#closures">Closures</a></h1><pre class='rust '>
    <span class='kw'>let</span> <span class='ident'>factor</span> <span class='op'>=</span> <span class='number'>8</span>;
    <span class='kw'>let</span> <span class='ident'>xs</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>(<span class='number'>1i</span>, <span class='number'>2i</span>, <span class='number'>3i</span>);
    <span class='kw'>let</span> <span class='ident'>ys</span> <span class='op'>=</span> <span class='ident'>xs</span>.<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>*</span> <span class='ident'>factor</span>);
    
    <span class='comment'>// ys == [8i, 16i, 24i]</span>
</pre>

<h1 id="structs-and-methods" class='section-header'><a
                           href="#structs-and-methods">Structs and methods</a></h1>
<h1 id="structs" class='section-header'><a
                           href="#structs">Structs</a></h1><pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Rectangle</span> {
    <span class='ident'>width</span>: <span class='ident'>f32</span>,
    <span class='ident'>height</span>: <span class='ident'>f32</span>
}
</pre>

<h1 id="static-methods" class='section-header'><a
                           href="#static-methods">Static methods</a></h1><pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Rectangle</span> { <span class='ident'>width</span>: <span class='ident'>f32</span>, <span class='ident'>height</span>: <span class='ident'>f32</span> }

<span class='kw'>impl</span> <span class='ident'>Rectangle</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>width</span>: <span class='ident'>f32</span>, <span class='ident'>height</span>: <span class='ident'>f32</span>) <span class='op'>-&gt;</span> <span class='ident'>Rectangle</span> {
        <span class='ident'>Rectangle</span> { <span class='ident'>width</span>: <span class='ident'>width</span>, <span class='ident'>height</span>: <span class='ident'>height</span> }
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>rect</span> <span class='op'>=</span> <span class='ident'>Rectangle</span>::<span class='ident'>new</span>(<span class='number'>1.2</span>, <span class='number'>4.9</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>react</span>.<span class='ident'>area</span>());
}
</pre>

<h1 id="member-methods" class='section-header'><a
                           href="#member-methods">Member methods</a></h1><pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Rectangle</span> { <span class='ident'>width</span>: <span class='ident'>f32</span>, <span class='ident'>height</span>: <span class='ident'>f32</span> }

<span class='kw'>impl</span> <span class='ident'>Rectangle</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f32</span> {
        <span class='self'>self</span>.<span class='ident'>width</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>height</span>   
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>rect</span> <span class='op'>=</span> <span class='ident'>Rectangle</span> {
        <span class='ident'>width</span>: <span class='number'>1.2</span>,
        <span class='ident'>height</span>: <span class='number'>4.9</span>
    };
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>react</span>.<span class='ident'>area</span>());
}
</pre>

<h1 id="traits" class='section-header'><a
                           href="#traits">Traits</a></h1>
<ul>
<li>No inheritance in Rust :)</li>
<li>No interfaces eitherâ€¦</li>
<li>Instead Rust provides a mechanism called <code>traits</code>.</li>
</ul>

<h1 id="traits-1" class='section-header'><a
                           href="#traits-1">Traits</a></h1>
<p>A trait is a sort of interface that defines some behavior.
If a type implements a trait, that means that it supports and implements the behavior the trait describes.</p>

<h1 id="traits-2" class='section-header'><a
                           href="#traits-2">Traits</a></h1>
<p>You can think of them as (better) Java interfaces. They are in fact very similar to Haskell&#39;s typeclasses.</p>

<p>One of the main difference is that you can define a trait implementation separately from the struct definition, even in another module. This means that you can eg. implement a trait you defined yourself for a type provided by a library.</p>

<p>They&#39;re also much more powerful (but won&#39;t get into too much detail here).</p>

<h1 id="traits-3" class='section-header'><a
                           href="#traits-3">Traits</a></h1><pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Rectangle</span> { <span class='ident'>width</span>: <span class='ident'>f32</span>, <span class='ident'>height</span>: <span class='ident'>f32</span> }

<span class='kw'>trait</span> <span class='ident'>HasArea</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f32</span>;
}

<span class='kw'>impl</span> <span class='ident'>HasArea</span> <span class='kw'>for</span> <span class='ident'>Rectangle</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f32</span> {
        <span class='self'>self</span>.<span class='ident'>width</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>height</span>
    }
}
</pre>

<h1 id="traits-4" class='section-header'><a
                           href="#traits-4">Traits</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>rect</span> <span class='op'>=</span> <span class='ident'>Rectangle</span> {
        <span class='ident'>width</span>: <span class='number'>1.2</span>,
        <span class='ident'>height</span>: <span class='number'>4.9</span>
    };
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>react</span>.<span class='ident'>area</span>());
}
</pre>

<h1 id="traits-5" class='section-header'><a
                           href="#traits-5">Traits</a></h1><pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Circle</span> { <span class='ident'>radius</span>: <span class='ident'>f32</span> }

<span class='kw'>impl</span> <span class='ident'>HasArea</span> <span class='kw'>for</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f32</span> {
         <span class='ident'>std</span>::<span class='ident'>f32</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span> <span class='op'>*</span> (<span class='self'>self</span>.<span class='ident'>radius</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>radius</span>)
    }
}
</pre>

<h1 id="traits-6" class='section-header'><a
                           href="#traits-6">Traits</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>print_area</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>shape</span>: <span class='ident'>T</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;This shape has an area of {}&quot;</span>, <span class='ident'>shape</span>.<span class='ident'>area</span>());
}
</pre>

<blockquote>
<p>error: type <code>T</code> does not implement any method in scope named <code>area</code></p>
</blockquote>

<h1 id="traits-7" class='section-header'><a
                           href="#traits-7">Traits</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>print_area</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>HasArea</span><span class='op'>&gt;</span>(<span class='ident'>shape</span>: <span class='ident'>T</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;This shape has an area of {}&quot;</span>, <span class='ident'>shape</span>.<span class='ident'>area</span>());
}
</pre>

<h1 id="traits-8" class='section-header'><a
                           href="#traits-8">Traits</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>print_area</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>HasArea</span><span class='op'>&gt;</span>(<span class='ident'>shape</span>: <span class='ident'>T</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;This shape has an area of {}&quot;</span>, <span class='ident'>shape</span>.<span class='ident'>area</span>());
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>Circle</span> { <span class='ident'>radius</span>: <span class='number'>1.0</span> }
    <span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>Rectangle</span> { <span class='ident'>width</span>: <span class='number'>3.0</span>, <span class='ident'>height</span>: <span class='number'>2.0</span> }

    <span class='ident'>print_area</span>(<span class='ident'>c</span>);
    <span class='ident'>print_area</span>(<span class='ident'>r</span>);
}
</pre>

<blockquote>
<p>This shape has an area of 3.141592654<br>
This shape has an area of 6.0</p>
</blockquote>

<h1 id="traits-9" class='section-header'><a
                           href="#traits-9">Traits</a></h1><pre class='rust '>
<span class='ident'>print_area</span>(<span class='number'>10i</span>);
</pre>

<blockquote>
<p>error: failed to find an implementation of trait <code>main::HasArea</code> for <code>int</code></p>
</blockquote>

<h1 id="traits-10" class='section-header'><a
                           href="#traits-10">Traits</a></h1>
<p>We can implement traits for any type. So this would work, even if it makes no sense:</p>
<pre class='rust '>
<span class='kw'>impl</span> <span class='ident'>HasArea</span> <span class='kw'>for</span> <span class='ident'>int</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;this is silly&quot;</span>);
        <span class='op'>*</span><span class='self'>self</span> <span class='kw'>as</span> <span class='ident'>f64</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='number'>10i</span>.<span class='ident'>area</span>();
    <span class='ident'>print_area</span>(<span class='number'>10i</span>);
}
</pre>

<p>Implementing traits for primitive types should generally be avoided.</p>

<h1 id="traits-11" class='section-header'><a
                           href="#traits-11">Traits</a></h1>
<p>One restriction:</p>

<blockquote>
<p>Either the trait or the type you&#39;re writing the <code>impl</code> for must be inside your crate.</p>
</blockquote>

<h1 id="a-few-built-in-traits" class='section-header'><a
                           href="#a-few-built-in-traits">A few built-in traits</a></h1><pre class='rust '>
<span class='kw'>trait</span> <span class='ident'>ToString</span> {
    <span class='kw'>fn</span> <span class='ident'>to_string</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span>;
}

<span class='kw'>trait</span> <span class='ident'>ToJson</span> {
    <span class='kw'>fn</span> <span class='ident'>to_json</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Json</span>;
}

<span class='kw'>trait</span> <span class='ident'>Equiv</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>equiv</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>other</span>: <span class='kw-2'>&amp;</span><span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;
}
</pre>

<h1 id="enums" class='section-header'><a
                           href="#enums">Enums</a></h1>
<ul>
<li>Also called <code>sum types</code> in the litterature.</li>
<li>Similar to Haskell&#39;s <code>data</code> and Scala&#39;s <code>case class</code>.</li>
</ul>
<pre class='rust '>
<span class='kw'>enum</span> <span class='ident'>Boolean</span> {
    <span class='ident'>True</span>,
    <span class='ident'>False</span>
}
</pre>

<blockquote>
<p>Rust&#39;s <code>bool</code> type is <strong>not</strong> implemented this way as it is a primitive.</p>
</blockquote>

<h1 id="enums-1" class='section-header'><a
                           href="#enums-1">Enums</a></h1><pre class='rust '>
<span class='kw'>enum</span> <span class='ident'>Boolean</span> {
    <span class='ident'>True</span>,
    <span class='ident'>False</span>
}

<span class='kw'>let</span> <span class='ident'>b</span>: <span class='ident'>Boolean</span> <span class='op'>=</span> <span class='ident'>True</span>;
</pre>

<p>A value of type <code>Boolean</code> can be either <code>True</code> or <code>False</code>.</p>

<h1 id="enum" class='section-header'><a
                           href="#enum">Enum</a></h1>
<p>From the standard library (almost):</p>
<pre class='rust '>
<span class='kw'>enum</span> <span class='ident'>Ordering</span> { <span class='ident'>Less</span>, <span class='ident'>Equal</span>, <span class='ident'>Greater</span> }

<span class='kw'>fn</span> <span class='ident'>cmp</span>(<span class='ident'>a</span>: <span class='ident'>int</span>, <span class='ident'>b</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>Ordering</span> {
    <span class='kw'>if</span>      <span class='ident'>a</span> <span class='op'>&lt;</span> <span class='ident'>b</span> { <span class='ident'>Less</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>a</span> <span class='op'>&gt;</span> <span class='ident'>b</span> { <span class='ident'>Greater</span> }
    <span class='kw'>else</span>          { <span class='ident'>Equal</span> }
}

<span class='kw'>let</span> <span class='ident'>ordering</span> <span class='op'>=</span> <span class='ident'>cmp</span>(<span class='ident'>x</span>, <span class='ident'>y</span>);

<span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Less</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;less&quot;</span>);
} <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Greater</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;greater&quot;</span>);
} <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Equal</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;equal&quot;</span>);
}
</pre>

<h1 id="pattern-matching" class='section-header'><a
                           href="#pattern-matching">Pattern matching</a></h1>
<p>Rust provides pattern matching, which lets you rewrite this:</p>
<pre class='rust '>
<span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Less</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;less&quot;</span>);
} <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Greater</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;greater&quot;</span>);
} <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>ordering</span> <span class='op'>==</span> <span class='ident'>Equal</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;equal&quot;</span>);
}
</pre>

<h1 id="pattern-matching-1" class='section-header'><a
                           href="#pattern-matching-1">Pattern matching</a></h1>
<p>into this:</p>
<pre class='rust '>
<span class='kw'>match</span> <span class='ident'>ordering</span> {
    <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;less&quot;</span>),
    <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;greater&quot;</span>),
    <span class='ident'>Equal</span>   <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;equal&quot;</span>)
}
</pre>

<h1 id="pattern-matching-2" class='section-header'><a
                           href="#pattern-matching-2">Pattern matching</a></h1>
<p>It also works with primitives:</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='number'>5i</span>;

<span class='kw'>match</span> <span class='ident'>i</span> {
    <span class='number'>0</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;zero&quot;</span>),
    <span class='number'>1</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;one&quot;</span>),
    _ <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;&gt; 1&quot;</span>)
}
</pre>

<h1 id="pattern-matching-3" class='section-header'><a
                           href="#pattern-matching-3">Pattern matching</a></h1>
<p>Patterns must be exhaustive:</p>
<pre class='rust '>
<span class='kw'>match</span> <span class='ident'>ordering</span> {
    <span class='ident'>Less</span>    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;less&quot;</span>),
    <span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;greater&quot;</span>)
}
</pre>

<blockquote>
<p>error: non-exhaustive patterns: <code>Equal</code> not covered [E0004]</p>
</blockquote>

<h1 id="pattern-matching-4" class='section-header'><a
                           href="#pattern-matching-4">Pattern matching</a></h1>
<p>There&#39;s a &quot;catch-all&quot; pattern: <code>_</code>.</p>
<pre class='rust '>
<span class='kw'>match</span> <span class='ident'>ordering</span> {
    <span class='ident'>Less</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;less&quot;</span>),
    _    <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;not less&quot;</span>) 
}
</pre>

<blockquote>
<p>error: non-exhaustive patterns: <code>Equal</code> not covered [E0004]</p>
</blockquote>

<h1 id="iterators" class='section-header'><a
                           href="#iterators">Iterators</a></h1>
<p>TOOD</p>

<h1 id="macros" class='section-header'><a
                           href="#macros">Macros</a></h1>
<p>TODO</p>

<h1 id="modules" class='section-header'><a
                           href="#modules">Modules</a></h1>
<p>TODO</p>

<h1 id="cargo" class='section-header'><a
                           href="#cargo">Cargo</a></h1>
<p>TODO</p>

<h1 id="thank-you!" class='section-header'><a
                           href="#thank-you!">Thank you!</a></h1>
<p>Questions?</p>

<h1 id="references" class='section-header'><a
                           href="#references">References</a></h1>
<ul>
<li><a href="http://doc.rust-lang.org/reference.html">http://doc.rust-lang.org/reference.html</a></li>
<li><a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a></li>
<li><a href="http://www.infoq.com/news/2012/08/Interview-Rust">http://www.infoq.com/news/2012/08/Interview-Rust</a></li>
<li><a href="http://theincredibleholk.wordpress.com/2012/05/30/safe-parallelism-in-rust/">http://theincredibleholk.wordpress.com/2012/05/30/safe-parallelism-in-rust/</a></li>
<li><a href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">http://blog.skylight.io/rust-means-never-having-to-close-a-socket/</a></li>
<li><a href="https://s3.amazonaws.com/f.cl.ly/items/351X3I3z0M1E251x3V1p/Hello%20Rust.pdf">https://s3.amazonaws.com/f.cl.ly/items/351X3I3z0M1E251x3V1p/Hello%20Rust.pdf</a></li>
<li><a href="http://lea-linux.org/documentations/Rust">http://lea-linux.org/documentations/Rust</a></li>
</ul>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
</body>
</html>