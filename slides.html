<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="generator" content="rustdoc">
    <title>Rust Workshop</title>

    
    <link rel="stylesheet" href="rust.css">
<link rel="stylesheet" href="sliderust.css">
<script src="sliderust.js"></script>


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <h1 class="title">Rust Workshop</h1>
    <p>HackEPFL</p>

<p>Dimiter Petrov &amp; Romain Ruetschi</p>

<p>November 12, 2014</p>

<h1 id="hello,-rust" class='section-header'><a
                           href="#hello,-rust">Hello, Rust</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, world!&quot;</span>);
}
</pre>
<pre class='rust '>
<span class='op'>&gt;</span> <span class='ident'>Hello</span>, <span class='macro'>world</span><span class='macro'>!</span>
</pre>

<h1 id="history" class='section-header'><a
                           href="#history">History</a></h1>
<ul>
<li>Started as a personal project in 2006 by Graydon Hoare</li>
<li>First compiler written in OCaml</li>
<li>Mozilla took over the project 3 years later</li>
<li>Compiler rewritten in Rust itself in 2010</li>
</ul>

<h1 id="why-rust-at-mozilla?" class='section-header'><a
                           href="#why-rust-at-mozilla?">Why Rust at Mozilla?</a></h1>
<ul>
<li>New experimental, highly parallel browser engine: Servo</li>
<li>Browsers evolve in a hostile, highly concurrent environment</li>
<li>Most security problems arise from memory safetey and concurrency issues</li>
<li>Thus needed a safer, saner systems language, with built-in concurrency</li>
</ul>

<h1 id="why-rust,-for-you?" class='section-header'><a
                           href="#why-rust,-for-you?">Why Rust, for you?</a></h1>
<ul>
<li>High-level features</li>
<li>Low-level control</li>
<li>Powerful Foreign Function Interface</li>
<li>Direct memory control</li>
<li>Guaranteed memory safety</li>
<li>Concurrency without data races</li>
<li>Zero cost abstractions</li>
</ul>

<h1 id="high-level-features" class='section-header'><a
                           href="#high-level-features">High-level features</a></h1>
<ul>
<li>Algebraic data types</li>
<li>Pattern matching</li>
<li>Higher-order functions</li>
<li>Closures</li>
<li>Traits (= type classes)</li>
<li>Type inference</li>
<li>Macros</li>
</ul>

<h1 id="low-level-control" class='section-header'><a
                           href="#low-level-control">Low-level control</a></h1>
<ul>
<li>Ability to trade compiler-enforced safety for lower-level control</li>
<li>Eg. dereferencing raw pointer, pointer arithmetic, calling extern code</li>
<li>Such unsafe code must be surrounded by an <code>unsafe</code> block</li>
<li>Thus easy to spot during code review or when debugging</li>
</ul>

<h1 id="powerful-ffi" class='section-header'><a
                           href="#powerful-ffi">Powerful FFI</a></h1>
<ul>
<li>Call Rust code from other languages (C, C++, or even GCed languages like Ruby)</li>
<li>Create bindings for libraries exposing a C interface</li>
</ul>

<h1 id="direct-memory-control" class='section-header'><a
                           href="#direct-memory-control">Direct memory control</a></h1>
<ul>
<li>No garbage collector</li>
<li>No runtime overhead</li>
<li>No unpredictable pauses in execution</li>
<li>TODO: Stack VS Heap</li>
</ul>

<h1 id="guaranteed-memory-safety" class='section-header'><a
                           href="#guaranteed-memory-safety">Guaranteed memory safety</a></h1>
<ul>
<li>No buffer overflows</li>
<li>No dangling pointers</li>
</ul>

<h1 id="concurrency-without-data-races" class='section-header'><a
                           href="#concurrency-without-data-races">Concurrency without data races</a></h1>
<ul>
<li>Only immutable data can be shared</li>
<li>Shared data must remain live as long as any task might access it</li>
</ul>

<h1 id="zero-cost-abstractions" class='section-header'><a
                           href="#zero-cost-abstractions">Zero cost abstractions</a></h1>
<p>Memory safety is enforced during compilation, there is no runtime overhead.</p>

<h1 id="but-how?" class='section-header'><a
                           href="#but-how?">But how?</a></h1>
<p>Rust is built around 3 concepts:</p>

<ul>
<li>Lifetime</li>
<li>Ownership</li>
<li>Borrowing</li>
</ul>

<h1 id="lifetime" class='section-header'><a
                           href="#lifetime">Lifetime</a></h1>
<p>Time span during which a resource (value) is valid.</p>

<h1 id="lifetime-1" class='section-header'><a
                           href="#lifetime-1">Lifetime</a></h1>
<p><img src="http://cl.ly/image/343C1X3o3K1s/Screen%20Shot%202014-11-10%20at%2018.06.58.png" alt=""></p>

<ul>
<li>You can think of it as a scope.</li>
<li>At the end of its lifetime, a value will be deallocated.</li>
</ul>

<h1 id="lifetime-2" class='section-header'><a
                           href="#lifetime-2">Lifetime</a></h1>
<pre><code class="language-c">{
    int *x = malloc(sizeof(int));

    *x = 5;

    free(x);
}
</code></pre>

<h1 id="lifetime-3" class='section-header'><a
                           href="#lifetime-3">Lifetime</a></h1><pre class='rust '>
{
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>5i</span>;
    
    <span class='comment'>// x gets deallocated here</span>
}
</pre>

<h1 id="move-&amp;-copy" class='section-header'><a
                           href="#move-&amp;-copy">Move &amp; Copy</a></h1>
<p>When you pass data to a function (or even assign it to a variable), that data can be copied, moved, or borrowed (more about it soon).</p>

<h1 id="copy" class='section-header'><a
                           href="#copy">Copy</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>add_one</span>(<span class='ident'>a</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>);
}

<span class='kw'>fn</span> <span class='ident'>add_one</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}
</pre>

<h1 id="move" class='section-header'><a
                           href="#move">Move</a></h1><pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Person</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
    <span class='ident'>age</span>: <span class='ident'>uint</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    <span class='ident'>show</span>(<span class='ident'>john</span>);
    
    <span class='comment'>// `john` has already been deallocated</span>
}

<span class='kw'>fn</span> <span class='ident'>show</span>(<span class='ident'>person</span>: <span class='ident'>Person</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is {}&quot;</span>, <span class='ident'>person</span>.<span class='ident'>name</span>, <span class='ident'>person</span>.<span class='ident'>age</span>);
    
    <span class='comment'>// `john` will be deallocated here</span>
}
</pre>

<h1 id="move-1" class='section-header'><a
                           href="#move-1">Move</a></h1><pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Person</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
    <span class='ident'>age</span>: <span class='ident'>uint</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    <span class='ident'>show</span>(<span class='ident'>john</span>);
    <span class='ident'>show</span>(<span class='ident'>john</span>);
}

<span class='kw'>fn</span> <span class='ident'>show</span>(<span class='ident'>person</span>: <span class='ident'>Person</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is {}&quot;</span>, <span class='ident'>person</span>.<span class='ident'>name</span>, <span class='ident'>person</span>.<span class='ident'>age</span>);
    
    <span class='comment'>// `john` will be deallocated here</span>
}
</pre>

<h1 id="move-2" class='section-header'><a
                           href="#move-2">Move</a></h1>
<pre><code class="language-norust">error: use of moved value: `john`
     show(john);
          ^
note: `john` moved here because it has type `Person`, which is non-copyable
     show(john);
          ^
error: aborting due to previous error
</code></pre>

<h1 id="move-3" class='section-header'><a
                           href="#move-3">Move</a></h1><pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='ident'>String</span>, <span class='ident'>age</span>: <span class='ident'>uint</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    
    <span class='comment'>// `john` moves into show here</span>
    <span class='ident'>show</span>(<span class='ident'>john</span>);
    <span class='comment'>// `john` is deallocated by now</span>
    <span class='comment'>// the next line thus doesn&#39;t compile</span>
    <span class='ident'>show</span>(<span class='ident'>john</span>);
}

<span class='kw'>fn</span> <span class='ident'>show</span>(<span class='ident'>person</span>: <span class='ident'>Person</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is {}&quot;</span>, <span class='ident'>person</span>.<span class='ident'>name</span>, <span class='ident'>person</span>.<span class='ident'>age</span>);
    
    <span class='comment'>// `john` will be deallocated here</span>
}
</pre>

<h1 id="move-(assignment)" class='section-header'><a
                           href="#move-(assignment)">Move (assignment)</a></h1>
<p>Assigning a value to a variable is similar to passing it to a function.</p>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='ident'>String</span>, <span class='ident'>age</span>: <span class='ident'>uint</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    
    <span class='comment'>// `john` moves into `john_bis` here</span>
    <span class='kw'>let</span> <span class='ident'>john_bis</span> <span class='op'>=</span> <span class='ident'>john</span>;
    
    <span class='comment'>// the next line thus won&#39;t compile</span>
    <span class='ident'>show</span>(<span class='ident'>john</span>);
}

<span class='kw'>fn</span> <span class='ident'>show</span>(<span class='ident'>person</span>: <span class='ident'>Person</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is {}&quot;</span>, <span class='ident'>person</span>.<span class='ident'>name</span>, <span class='ident'>person</span>.<span class='ident'>age</span>);
    
    <span class='comment'>// `john` will be deallocated here</span>
}
</pre>

<h1 id="ownership-&amp;-borrowing" class='section-header'><a
                           href="#ownership-&amp;-borrowing">Ownership &amp; Borrowing</a></h1>
<p>When you create a resource, you&#39;re the <strong>owner</strong> of that resource.</p>

<p>Being an owner affords you some privileges:</p>

<ul>
<li>You control when that resource is deallocated.</li>
<li>You may lend that resource, <strong>immutably</strong>, to <strong>as many</strong> borrowers as you&#39;d like.</li>
<li>You may lend that resource, <strong>mutably</strong>, to a <strong>single</strong> borrower.</li>
</ul>

<h1 id="ownership-&amp;-borrowing-1" class='section-header'><a
                           href="#ownership-&amp;-borrowing-1">Ownership &amp; Borrowing</a></h1>
<p>But it also comes with some restrictions:</p>

<ul>
<li>If someone is borrowing your resource (either mutably or immutably), you may not mutate the resource or mutably lend it to someone.</li>
<li>If someone is mutably borrowing your resource, you may not lend it out at all (mutably or immutably) or access it in any way.</li>
</ul>

<h1 id="borrow" class='section-header'><a
                           href="#borrow">Borrow</a></h1>
<blockquote>
<p>You may lend that resource, <strong>immutably</strong>, to <strong>as many</strong> borrowers as you&#39;d like.</p>
</blockquote>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='ident'>String</span>, <span class='ident'>age</span>: <span class='ident'>uint</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    
    <span class='comment'>// `john` moves into `show`.</span>
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>);
    
    <span class='comment'>// `show` hands us `john` back.</span>
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>);
    <span class='comment'>// the previous line will thus compile.</span>
}

<span class='kw'>fn</span> <span class='ident'>show</span>(<span class='ident'>person</span>: <span class='kw-2'>&amp;</span><span class='ident'>Person</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is {}&quot;</span>, <span class='ident'>person</span>.<span class='ident'>name</span>, <span class='ident'>person</span>.<span class='ident'>age</span>);
}
</pre>

<h1 id="borrow-1" class='section-header'><a
                           href="#borrow-1">Borrow</a></h1>
<pre><code class="language-norust">John is 42
John is 42
</code></pre>

<h1 id="mutable-borrow" class='section-header'><a
                           href="#mutable-borrow">Mutable borrow</a></h1>
<blockquote>
<p>You may lend that resource, <strong>mutably</strong>, to a <strong>single</strong> borrower.</p>
</blockquote>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='ident'>String</span>, <span class='ident'>age</span>: <span class='ident'>uint</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    
    <span class='ident'>grow_older</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>);
    
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>); <span class='comment'>// John is 43</span>
}

<span class='kw'>fn</span> <span class='ident'>grow_older</span>(<span class='ident'>person</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Person</span>) {
    <span class='ident'>person</span>.<span class='ident'>age</span> <span class='op'>+=</span> <span class='number'>1</span>;
}
</pre>

<h1 id="mutable-borrow-1" class='section-header'><a
                           href="#mutable-borrow-1">Mutable borrow</a></h1>
<p>The following will compile too, as <code>grow_older</code> gives us <code>john</code> back:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>); <span class='comment'>// John is 42</span>
    <span class='ident'>grow_older</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>);
    <span class='ident'>grow_older</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>);
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>); <span class='comment'>// John is 44</span>
}
</pre>

<h1 id="mutable-borrow-2" class='section-header'><a
                           href="#mutable-borrow-2">Mutable borrow</a></h1>
<p>But this won&#39;t:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>john_bis</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>;

    <span class='ident'>grow_older</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>);
    
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>);
}
</pre>

<h1 id="mutable-borrow-3" class='section-header'><a
                           href="#mutable-borrow-3">Mutable borrow</a></h1>
<pre><code class="language-norust">error: cannot borrow `john` as mutable more than once at a time
    grow_older(&amp;mut john);
                    ^
note: previous borrow of `john` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `p` until the borrow ends
    let mut john_bis = &amp;mut john;
                         ^
note: previous borrow ends here
fn main() {
...
}
^
error: aborting due to previous error
</code></pre>

<h1 id="mutable-borrow-4" class='section-header'><a
                           href="#mutable-borrow-4">Mutable borrow</a></h1><pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>john</span> <span class='op'>=</span> <span class='ident'>Person</span> { <span class='ident'>name</span>: <span class='string'>&quot;John&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>42</span> };

    <span class='comment'>// first borrow of `john` as mutable</span>
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>john_bis</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>;

    <span class='comment'>// `john` cannot be mutably borrowed again, won&#39;t compile</span>
    <span class='ident'>grow_older</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>john</span>);
    
    <span class='ident'>show</span>(<span class='kw-2'>&amp;</span><span class='ident'>john</span>);
}
</pre>

<h1 id="net-result" class='section-header'><a
                           href="#net-result">Net result</a></h1>
<ul>
<li>You never have to malloc or free </li>
<li>You never have to retain or release </li>
<li>Rust will deallocate a value when the current owner is done with it </li>
<li>The compiler will guarantee that borrowed values are not stolen</li>
</ul>

<h1 id="net-result-1" class='section-header'><a
                           href="#net-result-1">Net result</a></h1>
<ul>
<li>In low-level languages, we allocate and free memory, close sockets, etc.</li>
<li>In high-level languages, we never free memory, but we routinely close sockets and files, and release locks.</li>
<li>In Rust we do neither :)</li>
</ul>

<h1 id="thank-you!" class='section-header'><a
                           href="#thank-you!">Thank you!</a></h1>
<p>Questions?</p>

<h1 id="references" class='section-header'><a
                           href="#references">References</a></h1>
<ul>
<li><a href="http://doc.rust-lang.org/reference.html">http://doc.rust-lang.org/reference.html</a></li>
<li><a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a></li>
<li><a href="http://www.infoq.com/news/2012/08/Interview-Rust">http://www.infoq.com/news/2012/08/Interview-Rust</a></li>
<li><a href="http://theincredibleholk.wordpress.com/2012/05/30/safe-parallelism-in-rust/">http://theincredibleholk.wordpress.com/2012/05/30/safe-parallelism-in-rust/</a></li>
<li><a href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">http://blog.skylight.io/rust-means-never-having-to-close-a-socket/</a></li>
<li><a href="https://s3.amazonaws.com/f.cl.ly/items/351X3I3z0M1E251x3V1p/Hello%20Rust.pdf">https://s3.amazonaws.com/f.cl.ly/items/351X3I3z0M1E251x3V1p/Hello%20Rust.pdf</a></li>
<li><a href="http://lea-linux.org/documentations/Rust">http://lea-linux.org/documentations/Rust</a></li>
</ul>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
</body>
</html>